# Fuzzing Guide

## Quick Start

### Run all fuzz targets (Rust CLI)

**No setup required!** The runner automatically initializes the corpus from seeds if empty.

```bash
# Quick test - 60 seconds per target (default)
cargo run --bin fuzz-runner --release

# Custom time per target
cargo run --bin fuzz-runner --release -- --time 300    # 5 minutes per target
cargo run --bin fuzz-runner --release -- -t 120        # 2 minutes per target

# Run forever (no time limit per target)
cargo run --bin fuzz-runner --release -- --infinity

# Run for specific number of iterations
cargo run --bin fuzz-runner --release -- --max-iterations 10

# Combine options
cargo run --bin fuzz-runner --release -- -t 180 -m 5   # 3 min per target, 5 iterations
```

**Press Ctrl+C to stop gracefully** - it will finish the current target and exit cleanly.

## What Gets Tested

### 1. fuzz_word_count
- Core word counting with random byte sequences
- Both UTF-8 and SingleByte modes
- Catches panics, overflows, logic errors

### 2. fuzz_utf8
- UTF-8 edge cases and invalid sequences
- Validates invariants (chars ≤ bytes, lines ≤ bytes)
- Matches Rust stdlib for valid UTF-8

### 3. fuzz_simd_consistency
- Ensures all SIMD paths match scalar baseline
- Tests SSE2, AVX2, AVX512, NEON, SVE
- Both UTF-8 and SingleByte modes

## Directory Structure

```
fuzz/
├── seeds/                  ← YOUR editable seed files (git tracked)
│   ├── ascii.txt
│   ├── utf8.txt
│   ├── empty.txt
│   └── ...
│
├── corpus/shared/         ← Auto-generated by fuzzer (gitignored)
│   └── [100+ files]
│
├── logs/                  ← Fuzzing logs (gitignored)
│   ├── fuzz_*.log
│   └── stats_*.json
│
├── artifacts/             ← Crashes found (gitignored)
│   ├── fuzz_word_count/
│   ├── fuzz_utf8/
│   └── fuzz_simd_consistency/
│
└── fuzz_targets/          ← Test code
    ├── fuzz_word_count.rs
    ├── fuzz_utf8.rs
    └── fuzz_simd_consistency.rs
```

## Utilities

- `./init_corpus.sh` - Manually reset corpus from seeds (optional - runner does this automatically)
- `cargo run --bin fuzz-runner --release` - Fuzzing runner (Rust CLI with auto-init)

### Fuzz Runner Options

```bash
-t, --time <SECONDS>           Time per target per iteration (default: 60)
-i, --infinity                 Run forever (no time limit)
-m, --max-iterations <N>       Stop after N iterations
-h, --help                     Show help
```

## Managing Seeds

### Add new seed
```bash
echo "test case" > seeds/mytest.txt
./init_corpus.sh
```

### Clean corpus (keeps seeds safe)
```bash
# Just delete - runner will auto-initialize on next run
rm -rf corpus/shared/*

# Or manually initialize:
./init_corpus.sh
```

## Analyzing Results

### Check for crashes
```bash
ls -lh artifacts/*/
```

### Reproduce a crash
```bash
cargo fuzz run fuzz_word_count artifacts/fuzz_word_count/crash-abc123...
```

### Minimize crash input
```bash
cargo fuzz tmin fuzz_word_count artifacts/fuzz_word_count/crash-abc123...
```

### View statistics (Rust CLI)
```bash
cat logs/stats_*.json | jq .
```

## Tips

1. **Start small** - Run `./run_all.sh 60` first (60s per target)
2. **Run overnight** - Use `./fuzz-runner` for continuous testing
3. **Check often** - Crashes are saved to `artifacts/`
4. **Add seeds** - If you find edge cases, add them to `seeds/`
5. **Commit interesting corpus** - Share useful test cases with the team

## CI Integration

```bash
# In CI, run each target for a fixed time
cargo fuzz run fuzz_word_count corpus/shared -- -max_total_time=60
cargo fuzz run fuzz_utf8 corpus/shared -- -max_total_time=60
cargo fuzz run fuzz_simd_consistency corpus/shared -- -max_total_time=60

# Check exit codes for crashes
if [ -d "artifacts" ] && [ "$(find artifacts -type f)" ]; then
    echo "Crashes found!"
    exit 1
fi
```

## Advantages of Fuzzing

1. **Finds edge cases** - Discovers inputs you'd never think of
2. **Coverage-guided** - Automatically explores new code paths
3. **Continuous** - Keeps finding issues as you run it longer
4. **Reproducible** - Crashes are saved for debugging

## Rust CLI vs Bash Scripts

**Rust CLI** - The only way
- ✅ Proper signal handling (no crashes on Ctrl+C)
- ✅ Statistics tracking (coverage, exec/s, crashes)
- ✅ JSON export for analysis
- ✅ Clean, structured output
- ✅ Mutually exclusive argument groups
- ✅ Type-safe and maintainable
